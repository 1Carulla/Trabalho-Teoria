// turing_simulator.cpp
#include <bits/stdc++.h>
#include "json.hpp" // nlohmann::json (https://github.com/nlohmann/json)
using json = nlohmann::json;
using namespace std;

struct Transition {
    string to;
    char write;
    char dir; // 'R' ou 'L'
};

int main(int argc, char** argv) {
    if (argc != 3) {
        cerr << "Uso: " << argv[0] << " <arquivo_spec.json> <arquivo_entrada.txt>\n";
        return 1;
    }

    string spec_file = argv[1];
    string input_file = argv[2];

    // --- Ler JSON de especificação ---
    json spec;
    try {
        ifstream fin(spec_file);
        if (!fin.is_open()) {
            cerr << "Erro ao abrir arquivo de spec: " << spec_file << "\n";
            return 1;
        }
        fin >> spec;
    } catch (const std::exception& e) {
        cerr << "Erro ao ler/parsear JSON: " << e.what() << "\n";
        return 1;
    }

    // Campos esperados no JSON: initial, final (array), white, transitions (array)
    string initial_state = spec.value("initial", string());
    vector<string> final_states = spec.value("final", vector<string>{});
    string white_s = spec.value("white", string("_"));
    char white_symbol = white_s.empty() ? '_' : white_s[0];

    // Carregar transições em um mapa: key = estado + '|' + símbolo_lido
    unordered_map<string, Transition> transitions;
    if (spec.contains("transitions") && spec["transitions"].is_array()) {
        for (const auto& t : spec["transitions"]) {
            string from = t.value("from", string());
            string read_s = t.value("read", string());
            char read = read_s.empty() ? white_symbol : read_s[0];
            string to = t.value("to", string());
            string write_s = t.value("write", string());
            char write = write_s.empty() ? white_symbol : write_s[0];
            string dir_s = t.value("dir", string("R"));
            char dir = dir_s.empty() ? 'R' : dir_s[0];

            string key;
            key.reserve(from.size() + 2);
            key = from + "|" + read;

            transitions[key] = Transition{to, write, dir};
        }
    } else {
        cerr << "Spec JSON não contém 'transitions' como array.\n";
        return 1;
    }

    // Ler input
    string input_string;
    {
        ifstream fin(input_file);
        if (!fin.is_open()) {
            cerr << "Erro ao abrir arquivo de entrada: " << input_file << "\n";
            return 1;
        }
        // ler todo o arquivo em uma string, removendo espaços iniciais/finais
        std::ostringstream ss;
        ss << fin.rdbuf();
        input_string = ss.str();
        // trim simples (remover espaços e novas linhas nas extremidades)
        auto l = input_string.find_first_not_of(" \t\r\n");
        auto r = input_string.find_last_not_of(" \t\r\n");
        if (l == string::npos) input_string.clear();
        else input_string = input_string.substr(l, r - l + 1);
    }

    // --- Inicializar fita ---
    deque<char> tape;
    if (!input_string.empty()) {
        for (char c : input_string) tape.push_back(c);
    } else {
        tape.push_back(white_symbol);
    }

    int head = 0; // index relativo à fita (0..size-1)
    string state = initial_state;

    const long long max_iterations = 100000LL;
    long long iterations = 0;

    auto is_final = [&](const string& s) {
        return find(final_states.begin(), final_states.end(), s) != final_states.end();
    };

    bool halted_by_missing_transition = false;

    while (!is_final(state) && iterations < max_iterations) {
        ++iterations;

        // garantir que head esteja dentro da fita
        if (head < 0) {
            tape.push_front(white_symbol);
            head = 0;
        } else if (head >= (int)tape.size()) {
            tape.push_back(white_symbol);
        }

        char current_symbol = tape[head];
        string key = state + "|" + string(1, current_symbol);

        auto it = transitions.find(key);
        if (it == transitions.end()) {
            // Não há transição definida -> rejeita
            halted_by_missing_transition = true;
            break;
        }

        Transition tr = it->second;
        tape[head] = tr.write;
        state = tr.to;

        if (tr.dir == 'R' || tr.dir == 'r') {
            ++head;
        } else if (tr.dir == 'L' || tr.dir == 'l') {
            --head;
        } else {
            // se direção inválida, considerar como sem movimento (ou tratar erro)
            // aqui vamos não mover
        }
    }

    bool accepted = is_final(state) && (iterations < max_iterations || is_final(state));

    // Construir string da fita e remover símbolos brancos nas bordas (trim)
    string result_tape;
    result_tape.reserve(tape.size());
    for (char c : tape) result_tape.push_back(c);

    // trim do white_symbol nas extremidades
    auto first_non_white = result_tape.find_first_not_of(string(1, white_symbol));
    auto last_non_white = result_tape.find_last_not_of(string(1, white_symbol));
    string trimmed;
    if (first_non_white == string::npos) trimmed = ""; // fita só com brancos
    else trimmed = result_tape.substr(first_non_white, last_non_white - first_non_white + 1);

    // Escrever arquivo de saída com sufixo _out.txt
    string out_file;
    auto pos = input_file.rfind('.');
    if (pos == string::npos) out_file = input_file + "_out.txt";
    else out_file = input_file.substr(0, pos) + "_out.txt";

    {
        ofstream fout(out_file);
        if (!fout.is_open()) {
            cerr << "Erro ao criar arquivo de saída: " << out_file << "\n";
            // ainda assim imprimimos resultado no stdout
        } else {
            fout << trimmed;
        }
    }

    // Imprimir 1 se aceitou, 0 se rejeitou
    cout << (accepted ? '1' : '0') << '\n';

    // Retornar código de saída: 0 -> aceito, 1 -> rejeitado (espelho do script Python)
    return accepted ? 0 : 1;
}
